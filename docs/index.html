<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>graphdb.js</h1>
<p><a href="https://travis-ci.com/Ontotext-AD/graphdb.js"><img src="https://travis-ci.com/Ontotext-AD/graphdb.js.svg?branch=master" alt="Build Status"></a></p>
<p>A GraphDB and RDF4J data access library written in JavaScript to be used in Node.js.</p>
<h2>Installation</h2>
<p>Make sure you have Node.js version 8 or greater and Node Package Manager
(<a href="https://npmjs.org/">npm</a>) installed before start working with the library.</p>
<pre class="prettyprint source"><code>npm install graphdb
</code></pre>
<h2>Development</h2>
<h3>Setup Environment</h3>
<ul>
<li>Checkout or clone the project.</li>
<li>Make sure prerequisites are covered: node js and npm must be present and versions
should be supported.</li>
<li>Enter the project directory and execute</li>
</ul>
<pre class="prettyprint source"><code>npm install
</code></pre>
<h3>Running Tests</h3>
<p>After any change the tests should be run and check if any existing functionality
is not broken in result.</p>
<pre class="prettyprint source"><code>npm run test
</code></pre>
<p>or constantly watching for changes in source files and tests and re-execute the
test suite</p>
<pre class="prettyprint source"><code>npm run test:watch
</code></pre>
<p>The best and preferred way a new feature or changes to be introduced is a test
case to be written first and then the change to be implemented following the TDD
approach.</p>
<h3>Checking the codestyle</h3>
<p>The library uses Google <a href="https://google.github.io/styleguide/jsguide.html">style</a>
in conjunction with ESLint's recommended ruleset.</p>
<pre class="prettyprint source"><code>npm run lint
</code></pre>
<h3>Testing the packaging</h3>
<p>Library is managed by NPM package manager. During publishing npm consults the
<code>.gitignore</code>, <code>.npmignore</code> and <code>package.json#files</code> property in order to decide
which resources should be published. If any change in the project structure,
<code>.gitignore</code> or <code>.npmignore</code> is made, then publishing must be verified in order
to be guaranteed that needed sources will be properly published.
The packaging could be verified using the <code>npm package</code> command which generates
a <code>*.tgz</code> archive in the project root. The archive should contain only the needed
resources.
Furture the archive could be used as a source for <code>npm install</code> where the path
pointing the archive is provided.</p>
<h3>Production build</h3>
<p>The library is written in ES2016. During the build process source files <code>src/</code>
are transpiled to ES2015 and copied to <code>lib/</code> directory.</p>
<p>A typescript definition file <code>types.d.ts</code> is generated in the <code>lib/</code> as well.</p>
<p>Documentation is generated in <code>docs/</code> from the JSDoc annotations in the source
code.</p>
<pre class="prettyprint source"><code>npm run build
</code></pre>
<h3>Prerequisites</h3>
<p>Node &gt;= 8.16</p>
<h2>Usage</h2>
<h3>ServerClient</h3>
<p>The <code>ServerClient</code> deals with operations on server level like obtaining a list
with available repositories, concrete repository or deleting repositories. In
order to work with the <code>ServerClient</code> it should be configured <code>ServerClientConfig</code>
first.</p>
<ul>
<li>Configure <code>ServerClient</code></li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const {ServerClient, ServerClientConfig} = require('graphdb').server;
const {RDFMimeType} = require('graphdb').http;

const serverConfig = new ServerClientConfig('http://rdf4j-compliant-server/', 0, {
    'Accept': RDFMimeType.SPARQL_RESULTS_JSON
});
const server = new ServerClient(serverConfig);
</code></pre>
<ul>
<li>Fetch repository ids</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>server.getRepositoryIDs().then(ids => {
    // work with ids
}).catch(err => console.log(err));
</code></pre>
<ul>
<li>Check if repository with given name exists</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>server.hasRepository('repository-name').then(exists => {
    if (exists) {
        // repository exists -> delete it for example
    }
}).catch(err => console.log(err));
</code></pre>
<ul>
<li>Delete repository with given name</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>server.deleteRepository('repository-name').then(() => {
    // successfully deleted
}).catch(err => console.log(err));
</code></pre>
<ul>
<li>Although a repository instance can be created using a constructor which can be
seen in the examples below a client could obtain an instance of <code>RDFRepositoryClient</code>
through the server client</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>server.getRepository('repository-name').then(repository => {
    // repository is a configured RDFRepositoryClient instance
}).catch(err => console.log(err));
</code></pre>
<h3>RDFRepositoryClient</h3>
<ul>
<li>Instantiating repository client</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const readTimeout = 30000;
const writeTimeout = 30000;
const config = new RepositoryClientConfig(['http://GDB/repositories/my-repo'], {
  'Accept': RDFMimeType.TURTLE
}, '', readTimeout, writeTimeout);
const repository = new RDFRepositoryClient(config);
</code></pre>
<ul>
<li>Obtaining repository client instance through a ServerClient</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const {ServerClient, ServerClientConfig} = require('graphdb').server;
const {RepositoryClientConfig} = require('graphdb').repository;

const config = new ServerClientConfig('http://GDB', 0, {});
const server = new ServerClient(config);

const readTimeout = 30000;
const writeTimeout = 30000;
const repositoryClientConfig = new RepositoryClientConfig(['http://GDB/repositories/my-repo'], {}, '', readTimeout, writeTimeout);
return server.getRepository('automotive', repositoryClientConfig).then((rdfRepositoryClient) => {
// rdfRepositoryClient is a configured instance of RDFRepositoryClient
});
</code></pre>
<h4>Reading</h4>
<p>Statements could be fetched using the <code>RDFRepositoryClient.get</code>, <code>RDFRepositoryClient.query</code>,
<code>RDFRepositoryClient.download</code>.</p>
<p>Every reading method can get the response parsed to data objects according to
<a href="http://rdf.js.org/data-model-spec/">RDFJS</a> data model specification (see <a href="#response-parsers">Response Parsers</a>).</p>
<ul>
<li>Reading statements</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const payload = new GetStatementsPayload()
	.setResponseType(RDFMimeType.RDF_JSON)
	.setSubject('&lt;http://eunis.eea.europa.eu/countries/AZ>')
	.setPredicate('&lt;http://eunis.eea.europa.eu/rdf/schema.rdf#population>')
	.setObject('&quot;7931000&quot;^^http://www.w3.org/2001/XMLSchema#integer')
	.setContext('&lt;http://example.org/graph3>')
	.setInference(true);

return repository.get(payload).then((data) => {
	// data contains requested staments in rdf json format
});
</code></pre>
<ul>
<li>Downloading data from repository by consuming a WritableStream</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const dest = __dirname + '/statements.ttl';
const output = fs.createWriteStream(dest);
const payload = new GetStatementsPayload()
    .setResponseType(RDFMimeType.TURTLE)
    .get();
repository.download(payload).then((response) => {
    response.on('data', (chunk) => {
        output.write(new Buffer(chunk));
    });
    response.on('end', () => {
        output.end();
    });
});
</code></pre>
<ul>
<li>
<p>Query evaluation against a sparql endpoint</p>
</li>
<li>
<p>SELECT query returning data objects</p>
</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>repository.registerParser(new SparqlXmlResultParser());

const payload = new GetQueryPayload()
  .setQuery('select * where {?s ?p ?o}')
  .setQueryType(QueryType.SELECT)
  .setResponseType(RDFMimeType.SPARQL_RESULTS_XML)
  .setLimit(100);

return repository.query(payload).then((stream) => {
  stream.on('data', (bindings) => {
    // the bindings stream converted to data objects with the registered parser
  });
  stream.on('end', () => {
    // handle end of the stream
  });
});
</code></pre>
<ul>
<li>ASK query returning a boolean result</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const payload = new GetQueryPayload()
  .setQuery('ask {?s ?p ?o}')
  .setQueryType(QueryType.ASK)
  .setResponseType(RDFMimeType.BOOLEAN_RESULT);

repository.registerParser(new SparqlJsonResultParser());

return repository.query(payload).then((data) => {
  // data => true|false
});
</code></pre>
<h4>Writing</h4>
<ul>
<li>Uploading data in repository (POST) using ReadStream</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const contentType = RDFMimeType.TURTLE;
const turtleFile = __dirname + '/statements.ttl';
fs.readFile(turtleFile, (err, stream) => {
    repository.upload(stream, null, null, contentType).catch((e) => console.log(e));
});
</code></pre>
<ul>
<li>Overwriting data in repository (PUT) using ReadStream</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const contentType = RDFMimeType.TURTLE;
const file = __dirname + '/statements-overwrite.ttl';
fs.readFile(file, (err, stream) => {
    repository.overwrite(stream, null, null, contentType).catch((e) => console.log(e));
});
</code></pre>
<ul>
<li>Executing a sparql update query</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const payload = new UpdateQueryPayload()
  .setQuery('INSERT {?s ?p ?o} WHERE {?s ?p ?o}')
  .setContentType(QueryContentType.X_WWW_FORM_URLENCODED)
  .setInference(true)
  .setTimeout(5);

return repository.update(payload).then(() => {
    // repository should have been updated at this point
});
</code></pre>
<h4>Deleting</h4>
<ul>
<li>Delete statement from given context</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>repository.deleteStatements(subj, pred, obj, contexts).then(() => {

});
</code></pre>
<h3>Transactions</h3>
<p>Repository operations can be executed in transaction. In order to work with
transactions the <code>TransactionalRepositoryClient</code> is used.</p>
<h4>Starting a transaction</h4>
<p><code>RDFRepositoryClient</code> can initiate a transaction via <code>beginTransaction()</code> which
produces an instance of <code>TransactionalRepositoryClient</code>.</p>
<p>Each started transaction allows to be committed or rolled back by using
respectively <code>commit()</code> and <code>rollback()</code></p>
<p>The following is a short use example of a transaction:</p>
<pre class="prettyprint source lang-javascript"><code>const turtlePath = __dirname + '/statements.ttl';

let transactionClient;
return repository.beginTransaction().then((transaction) => {
  transactionClient = transaction;
  return transactionClient.addFile(turtlePath);
}).then(() => {
  // File upload was successful, commit the changes
  return transactionClient.commit();
}).catch((e) => {
  console.log(e);
  if (transactionClient) {
    // Couldn't upload the file, abort the transaction
    return transactionClient.rollback();
  }
  return Promise.reject(e);
});
</code></pre>
<p>For specific isolation level use <code>TransactionIsolationLevel</code></p>
<pre class="prettyprint source lang-javascript"><code>return repository.beginTransaction(TransactionIsolationLevel.READ_UNCOMMITTED);
</code></pre>
<p>The default isolation level is specific for each store implementation.</p>
<p><strong>Important:</strong> After commit or rollback, a transaction cannot be reused, any
attempts will result in an error. If you are not sure what is the state of the
transaction, you can use <code>transaction.isActive()</code></p>
<h4>Working with a transaction</h4>
<p>Almost all of the transaction methods for reading &amp; modifying data have the same
syntax and parameters as those in <code>RDFRepositoryClient</code>.</p>
<h5>Reading</h5>
<p><code>TransactionalRepositoryClient</code> supports the following methods for reading data,
including any changes that are not yet committed:</p>
<ul>
<li><code>getSize()</code></li>
<li><code>get()</code></li>
<li><code>download()</code></li>
<li><code>query()</code></li>
</ul>
<h5>Writing</h5>
<ul>
<li><code>add()</code></li>
<li><code>addQuads()</code></li>
<li><code>upload()</code></li>
<li><code>addFile()</code></li>
</ul>
<h4>Deleting</h4>
<p>Deleting data during a transaction is different than the one in
<code>RDFRepositoryClient</code>, it expects RDF data document instead of statements
filter parameters.</p>
<p>Currently it supports only Turtle or TriG formatted RDF data:</p>
<pre class="prettyprint source lang-javascript"><code>const turtlePath = __dirname + '/statements.ttl';
const turtleData = fs.readFileSync(turtlePath, 'utf8');
return transaction.deleteData(turtleData);
</code></pre>
<h3>Namespaces</h3>
<ul>
<li>Retrieving all available namespace declarations. The resolved value is an
array of <code>Namespace</code> instances.</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>return repository.getNamespaces().then((namespaces) => {
  namespaces.forEach((namespace) => {
    console.log(namespace.getPrefix() + ' -> ' + namespace.getNamespace());
   });
})
</code></pre>
<ul>
<li>Retrieving specific namespace declaration</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>return repository.getNamespace('rdf').then((namespace) => {
  console.log(namespace);
})
</code></pre>
<ul>
<li>Setting the namespace declaration. This can act as create or update:</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>return repository.saveNamespace('rdf', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');
</code></pre>
<ul>
<li>Deleting specific namespace declaration</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>return repository.deleteNamespace('rdf');
</code></pre>
<ul>
<li>Deleting all namespaces declarations</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>return repository.deleteNamespaces();
</code></pre>
<h3>Response Parsers</h3>
<p>Read responses of different content types might be parsed to data objects with
parsers registered in the repository instance.</p>
<p>The library provides a way parsers to be implemented and registered with given
repository instance which in turn will use them to parse the response before
returning it to the client.</p>
<h4>Implementing a custom parser</h4>
<p>A parser could be implemented by extending the <code>ContentParser</code> and implementing
the <code>parse</code> and <code>getSupportedType</code> methods.</p>
<pre class="prettyprint source lang-javascript"><code>class RdfAsJsonParser extends ContentParser {
  getSupportedType() {
    return 'application/rdf+json';
  }

  parse(content) {
    // parse and return the content
    return parsedContent;
  }
}
</code></pre>
<p>The <code>getSupportedType</code> method must return one of the supported RDF and SPARQL
MIME types this way defining that the parser is responsible for converting from
that type.</p>
<h4>Register parser in the repository</h4>
<p>Parsers should be registered in the repository before executing any request.</p>
<pre class="prettyprint source lang-javascript"><code>// Import any of the predefined parsers
const {NTriplesParser} = require('graphdb').parser;
// And register it in the repository
repository.registerParser(new NTriplesParser());
</code></pre>
<p>Multiple parsers could be registered for different response types.</p>
<p><code>Registering a second parser for same content type results in overriding the previously registerted parser!</code></p>
<h4>Predefined parsers</h4>
<p>The library provides parsers for rdf formats using the <a href="https://github.com/rdfjs/N3.js">N3</a> library:</p>
<ul>
<li>TurtleParser: <code>text/turtle</code></li>
<li>N3parser: <code>text/rdf+n3</code></li>
<li>NQuadsParser: <code>text/x-nquads</code></li>
<li>NTriplesParser: <code>text/plain</code> (<code>N-Triples</code>)</li>
<li>TrigParser: <code>application/x-trig</code></li>
</ul>
<p>For SELECT query results in <code>json</code> and <code>xml</code> formats as well as boolean results
from ASK queries following parsers are wrapped and exposed:
<a href="https://github.com/rubensworks/sparqlxml-parse.js">sparqlxml-parse</a> and
<a href="https://github.com/rubensworks/sparqljson-parse.js">sparqljson-parse</a></p>
<ul>
<li>SparqlXmlResultParser: <code>application/sparql-results+xml</code>, <code>text/boolean</code></li>
<li>SparqlJsonResultParser: <code>application/sparql-results+json</code>, <code>text/boolean</code></li>
</ul>
<h3>License</h3>
<p><a href="LICENSE">LICENSE</a></p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AddStatementPayload.html">AddStatementPayload</a></li><li><a href="BaseRepositoryClient.html">BaseRepositoryClient</a></li><li><a href="CommonUtils.html">CommonUtils</a></li><li><a href="ConsoleLogger.html">ConsoleLogger</a></li><li><a href="ContentParser.html">ContentParser</a></li><li><a href="FileUtils.html">FileUtils</a></li><li><a href="GetQueryPayload.html">GetQueryPayload</a></li><li><a href="GetStatementsPayload.html">GetStatementsPayload</a></li><li><a href="HttpClient.html">HttpClient</a></li><li><a href="HttpRequestConfigBuilder.html">HttpRequestConfigBuilder</a></li><li><a href="HttpResponse.html">HttpResponse</a></li><li><a href="Iterable.html">Iterable</a></li><li><a href="JsonLDParser.html">JsonLDParser</a></li><li><a href="N3Parser.html">N3Parser</a></li><li><a href="Namespace.html">Namespace</a></li><li><a href="NQuadsParser.html">NQuadsParser</a></li><li><a href="NTriplesParser.html">NTriplesParser</a></li><li><a href="PagedResponse.html">PagedResponse</a></li><li><a href="ParserRegistry.html">ParserRegistry</a></li><li><a href="QueryPayload.html">QueryPayload</a></li><li><a href="RDFRepositoryClient.html">RDFRepositoryClient</a></li><li><a href="RDFXmlParser.html">RDFXmlParser</a></li><li><a href="RepositoryClientConfig.html">RepositoryClientConfig</a></li><li><a href="ResponseIterator.html">ResponseIterator</a></li><li><a href="ServerClient.html">ServerClient</a></li><li><a href="ServerClientConfig.html">ServerClientConfig</a></li><li><a href="SparqlJsonResultParser.html">SparqlJsonResultParser</a></li><li><a href="SparqlXmlResultParser.html">SparqlXmlResultParser</a></li><li><a href="StatementPayload.html">StatementPayload</a></li><li><a href="StringUtils.html">StringUtils</a></li><li><a href="TermConverter.html">TermConverter</a></li><li><a href="TransactionalRepositoryClient.html">TransactionalRepositoryClient</a></li><li><a href="TriGParser.html">TriGParser</a></li><li><a href="TurtleParser.html">TurtleParser</a></li><li><a href="UpdateQueryPayload.html">UpdateQueryPayload</a></li></ul><h3>Interfaces</h3><ul><li><a href="Logger.html">Logger</a></li></ul><h3>Global</h3><ul><li><a href="global.html#PATH_NAMESPACES">PATH_NAMESPACES</a></li><li><a href="global.html#PATH_STATEMENTS">PATH_STATEMENTS</a></li><li><a href="global.html#QueryContentType">QueryContentType</a></li><li><a href="global.html#QueryLanguage">QueryLanguage</a></li><li><a href="global.html#QueryType">QueryType</a></li><li><a href="global.html#RDFMimeType">RDFMimeType</a></li><li><a href="global.html#RETRIABLE_STATUSES">RETRIABLE_STATUSES</a></li><li><a href="global.html#TransactionIsolationLevel">TransactionIsolationLevel</a></li><li><a href="global.html#XSD">XSD</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.2</a> on Wed Jun 05 2019 13:47:20 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>